# 一致性与共识

# 前言

总结：数据系统首先要满足各种需求才称得上有用，比如一些基本功能需求（它应该做什么，比如允许以各种方式存储，检索，搜索和处理理数据）以及一些非功能性需求（nonfunctional ）（通⽤属性，例如安全性，可靠性，合规性，可扩展性，兼容性和可维护性）

第二章 关于数据模型，即基于各种应用需求的模型，比如文档层次模型、Nosql, 数据库关系模型、图模型，全文搜索，GenBak、LHC硬件，从基础的特性（写入和查询），然后讲了一些场景下的解决方案

第三章 针对数据模型中的的写入和查询，介绍了常见数据库如何处理存储和检索

第四章 研究了数据结构转换为网络中的字节或磁盘上的字节的几种方法，以及重点强调了前后兼容性

我们讨论了数据系统的各个方面，但仅限于数据存储在单台机器器上的情况。

第二部分，进入更高的层次，引入了分布式系统出现的原因，摩尔定律以及突破，并提出一个问题：如果多台机器器参与数据的存储和检索，会发生什么，引出了分布式系统的可扩展，HA等，针对扩展提出了复制和分区两种方法，以及分布式事务，然后引出了分布式系统下的各种问题和挑战

# 一致性保证

分布式下面，任何可能出现出错的地方都会出错，一致性保证一般就是在异常下的保证，或者为了保证全局一致性要增加不一致的牺牲，比如区块链中的共识算法

事务隔离主要是为了，避免由于同时执行事务而导致的竞争状态，而分布式一致性主要关于，面对延迟和故障时，如何协调副本间的状态，

-   首先介绍常用的一致性模型，线性一致性的优缺点
-   其次介绍分布式系统中事件顺序的问题，特别是顺序一致性、因果一致性的问题。
-   第三部分将探讨如何原子地提交分布式事务，这将最终引领我们走向共识问题的解决方案。

# 线性一致性

大多数复制的数据库至少提供了最终一致性，这意味着如果你停止向数据库写入数据并等待一段不确定的时间，那么最终所有的读取请求都会返回相同的值。换句话说，不一致性是暂时的，最终会自行解决（假设网络中的任何故障最终都会被修复）。最终一致性的一个更好的名字可能是收敛,因为我们预计所有的复本最终会收敛到相同的值。在最终一致的数据库，如果你在同一时刻问两个不同副本相同的问题，可能会得到两个不同的答案。这很让人困惑。如果数据库可以提供只有一个副本的假象（即，**只有一个数据副本**），那么事情就简单太多了。那么每个客户端都会有相同的数据视图，且不必担心复制滞后了。这就是线性一致性(linearizability）背后的想法线性一致性的精确定义相当微妙，基本的想法是让一个系统看起来好像只有一个数据副本，而且所有的操作都是原子性的。有了这个保证，即使实际中可能有多个副本，应用也不需要担心它们。

**来看一个问题**

![](https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=ODZlNGEzMGY1ZWMzODQ2MTk1NmZhYzc1ZDNmOTJiOWRfcUNWVWlSejVyTXpUOWtQdHVEQkFlUFhjWjB1QlNZdWdfVG9rZW46Ym94Y242S1lOanRFaUZxbWVnamRYYXp1VzF2XzE2NTEyMDU3MDE6MTY1MTIwOTMwMV9WNA)

一个关于体育网站的非线性一致例子。Alice和Bob正坐在同一个房间里，都盯着各自的手机，关注着2014年FIFA世界杯决赛的结果。在最后得分公布后，Alice刷新页面，看到宣布了获胜者，并兴奋地告诉Bob。Bob难以置信地刷新了自己的手机，但他的请求路由到了一个落后的数据库副本上，手机显示示比赛仍在讲行，这就违背了单一副本，即线性一致性的要求

## 什么使得系统线性一致

怎么来保证系统中看起来只有一个数据副本

（1）如果读取请求与写入请求并发，则可能会返回旧值或新值

![](https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWM0YzYxZDMyZGI2YzJlYjNlZDIzNzBlOWQ0NjQ3MjlfWFI2THNsV29JSWVRNWRIWmdDMkd3RllxcDlYRE4zM1pfVG9rZW46Ym94Y25Ba3M5a3RWTE03V0ZtRGM1ZUVISzJkXzE2NTEyMDU3MDE6MTY1MTIwOTMwMV9WNA)

三个客户端，读取相同键x的值，x被称为寄存器(register),例如，它可以是键值存储中的一个键，关系数据库中的一行，或文档数据库中的个文档。从用户视角来看的时序图，这里有两种类型的操作

-   $read(X)→v$表示客户端请求读取寄存器x的值，数据库返回值v。
-   $writ(X,v)→r$表示客户端请求将寄存器x设置为值v,数据库返回响应x(可能正确，可能错误)。

x的值最初为0，客户端C执行写请求将其设置为1。发生这种情况时，客户端A和B反复轮询数据库以读取最新值。A和B的请求可能会收到怎样的响应？·

-   客户端A的第一个读操作，完成于写操作开始之前，因此必须返回旧值0。
-   客户端A的最后一个读操作，开始于写操作完成之后。如果数据库是线性一致性的，它必然返回新值1, 因为读操作和写操作一定是在其各自的起止区间内的某个时刻被处理。如果在写入结束后开始读取，则必须在写入之后处理读取，因此它必须看到写入的新值。
-   写操作在时间上重叠的任何读操作，可能会返回0或1，因为我们不知道读取时，写操作是否已经生效。这些操作是并发(concurrent)的。

如果与写入同时发生的读取可以返回旧值或新值, 可能会在写⼊期间看到数值在旧值和新值之间来回翻转,所以可以添加另外一个约束，

（2）任何一个读取返回新值后，所有后续读取（在相同或其他客户端上）也必须返回新值。

![](https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=NmM1MzU1MjMzZmQwOTUwNTA2NzYzOWFhZTk4OGIwNWNfdW9zdXFHZnVZRHBDdXd6TU1LM0pkTnJjb2VnVUZBTG5fVG9rZW46Ym94Y25aMHZacGFVWmEyUGFPbUV2UjBBWG5jXzE2NTEyMDU3MDE6MTY1MTIwOTMwMV9WNA)

在 x 的值从 0 自动翻转到 1 的时候（在写操作的开始和结束之间）必定有一个时间点。因此，如果⼀一个客户端的读取返回新的值 1 ，即使写操作尚未完成，所有后续读取也必须返回新值，这样就从增加时序依赖上，限定了一个顺序

（3）每次读取都必须返回最近一次写入设置的值

$cas(x, v{old}, v{new})⇒r$ 表示客户端请求进⾏原子性的比较与设置操作。如果寄存器 $x$ 的当前值等于 $v{old}$ ，则应该原子地设置为 $v{new}$ 。如果 $x≠v_{old}$ ，则操作应该保持寄存器不变并返回一个错误。 $r$ 是数据库的响应（正确或错误）

![](https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=MzA5Y2MxNDQ5ZjlhZWRhYTYzMjg5ZGY5MzgwNWVjNWFfc29UTjZCbjU4MUVFU0p0bzdqZEtmU1RKVUY0Z1dXU0tfVG9rZW46Ym94Y25uU2l0dTRSRGhBam1qWmpodHpZSmJnXzE2NTEyMDU3MDE6MTY1MTIwOTMwMV9WNA)

线性一致性是非常重要的一个一致性模型，在分布性锁、Leader 选举、唯一性约束等很多场景都可以看到它的身影。对于线性一致性的描述，我们可以从读写操作的维度来描述。

-   对于写操作来说，任意两个写操作 x1 和 x2：
    -   如果写 x1 操作和写 x2 操作有重叠，那么可能 x1 覆盖 x2，也可能 x2 覆盖 x1；
    -   如果写 x1 操作在写 x2 开始前完成，那么 x2 一定覆盖 x1。
-   对于读操作来说：
    -   写操作完成后，所有的客户端都能立即观察到；
    -   对于多个客户端来说，必须读取到一样的顺序。

我们可以看到，线性一致性保证了所有的读取都可以读到最新写入的值，即一旦新的值被写入或读取，所有后续的读都会看到写入的值，直到它被再次覆盖。在线性一致性模型中不论是数据的覆盖顺序还是读取顺序，都是按时间线从旧值向新值移动，而不会出现旧值反转的情况。

## 实现线性一致的系统

-   单主复制 （可能）
-   共识算法（线性一致）区块链中新块的生成
-   多主复制（非））
-   无主复制（也许）

线性一致性和法定人数

![](https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=MWMwNTQyNWNlZDllNDk0MDA0ZDBhNmU0NjNmZjcxMTlfYlBHMlpUSWZVQ3dGTTJHVE1VVDhTQ1RLQnkzaDhGUmlfVG9rZW46Ym94Y25RSFZjS2RPS1NkajZIdXlUbkpMNUVlXzE2NTEyMDU3MDE6MTY1MTIwOTMwMV9WNA)

在图中，$x$的初始值为0，写入客户端通过向所有三个副本（$=3，w=3$)发送写入将$x$更

新为1。客户端A并发地从两个节点组成的法定人群（$r=2$)中读取数据，并在其中一个节点上看

到新值1。客户端B也并发地从两个不同的节点组成的法定人数中读取，并从两个节点中取回了旧值

0，仲裁条件满足（$W+>n$),但是这个执行是非线性一致的：B的请求在A的请求完成后开始，但是B 返回旧值，而A返回新值。（如同Alice和Bob的例子)

但是，通过牺牲性能，可以使Dynamol风格的法定人数线性化：读取者必须在将结果返回给应用之前，同步执行读修复（参阅“读时修复与反熵过程”），并且写入者必须在发送写入之前，读取法定数量节点的最新状态。然而，由于性能损失，Riak不执行同步读修复。Cassandra在进行法定人数读取时，确实在等待读修复完成；但是由于使用了最后写入为准的冲突解决方案，当同一个键有多个并发写入时，将不能保证线性一致性。而且，这种方式只能实现线性一致的读写；不能实现线性一致的比较和设置操作，因为它需要一个共识算法，总而言之，最安全的做法是：假设采用Dynamol风格无主复制的系统不能提供线性一致性。

## 线性一致性的代价

-   网络中断迫使在线性一致性和可用性之间做出选择
-   CAP定理
    -   一个分布式系统不可能同时满足数据一致性、服务可用性和分区容错性这三个基本需求，最多只能同时满足其中的两个
    -   在满足分区容错的前提下，没有算法能同时满足数据一致性和服务可用性。

# 顺序保证

每个操作似乎都是在某个时间点以原子性的方式生效的。这个定义意味着操作是按照某种良好定义的顺序执⾏行的。我们通过操作（似乎）执行完毕的顺序来连接操作

## 顺序一致性

在论文中具体的定义如下：

> A multiprocessor is said to be sequentially consistent if the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program.

> 如果任何执行的结果与所有处理器的操作都以某种顺序执行的结果相同，并且每个单独的处理器的操作按照其程序顺序出现在该序列中，则称多处理器是顺序一致的。

线性一致性容易和可序列化相混淆，因为两个词似乎都是类似“可以按顺序排列“的东西。但它们是

两种完全不同的保证，区分两者非常重要：

对于顺序一致性，论文中的定义虽然严谨，但是理解起来也是有难度的，它需要掌握一些前置的定义，比如 “program order”。不过在这里，我们依然可以用简单的语言来描述。

-   对于写操作来说，任意两个写操作 x1 和 x2：
    -   如果写 x1 操作和写 x2 操作有重叠，那么可能 x1 覆盖 x2，也可能 x2 覆盖 x1；
    -   当写 x1 操作在写 x2 开始前完成，如果两个写操作没有因果关系，当写 x1 操作在写 x2 开始前完成，那么有可能 x1 覆盖 x2，也有可能 x2 覆盖 x1；如果两个写操作有因果关系，即同一台机器节点先写 x1，或者先看到 x1 然后再写 x2，则所有节点必须用 x2 覆盖 x1。
-   对于读操作来说：
    -   如果写操作 x2 覆盖 x1 完成，那么如果一个客户端到 x2 后，它就无法读取到 x1 了，但是这个时候，其他的客户端还可以观察到 x1；
    -   对于多个客户端来说，必须观察到一样的顺序。

相对于线性一致性来说，顺序一致性在一致性方面有**两点放松**：

-   对于写操作，对没有因果关系的非并发写入操作，不要求严格按时间排序；
-   对于读操作，只要求所有的客户端观察到的顺序一致性，不要求写入后，所有的客户端都必须读取新值。

## 因果一致性

一种一致性强度低于顺序一致性的模型。在这里，我们依然从读写操作的维度来进行描述。对于写操作来说，

-   任意两个写操作 x1 和 x2：
    -   如果两个写操作没有因果关系，那么写 x1 操作在写 x2 开始前完成，有的节点是 x1 覆盖 x2，有的节点则 x2 可能覆盖 x1；
    -   如果两个写操作有因果关系，即同一台机器节点先写 x1，或者先看到 x1 然后再写 x2，则所有节点必须用 x2 覆盖 x1。对于读操作来说：如果写操作 x2 覆盖 x1 完成，那么如果一个客户端到 x2 后，它就无法读取到 x1 了，但是这个时候，其他的客户端还可以观察到 x1。

相对于顺序一致性来说，因果一致性在一致性方面有两点放松：

-   对于写操作，对没有因果关系的非并发写入操作，不仅不要求按时间排序，还不再要求节点之间的写入顺序一致了；
-   对于读操作，由于对非并发写入顺序不再要求一致性，所以自然也无法要求多个客户端必须观察到一样的顺序。

## 序列号顺序

虽然因果是一个重要的理论概念，但实际上跟踪所有的因果关系是不切实际的。在许多应用中，客户端在写入内容之前会先读取大量数据，我们无法弄清写入因果依赖于先前全部的读取内容，还是仅包括其中一部分。显式跟踪所有已读数据意味着巨大的额外开销。 但还有一个更好的方法：我们可以使用序列号(sequence nunber)或时间戳(timestamp)来排序事件。时间戳不一定来自时钟（或物理时钟，存在许多问题，如“不可靠时钟”中所述）。它可以来自一 个逻辑时钟(logical clock),这是一个用来生成标识操作的数字序列的算法，典型实现是使用一个每 次操作自增的计数器。

-   非因果序列号生成器 奇数，偶数节点
-   兰伯特时间器 使用节点id + 计数器

## 全序广播

-   使用全序广播
-   使用全序广播实现线性一致性
-   使用线性一致性存储实现全序广播

## 最终一致性

它是 Amazon 基于 Dynamo 等系统的实战经验所总结的一种很务实的实现，它不同于前面几种由大学计算机科学的教授提出的一致性模型，所以也没有非常学院派清晰的定义，但是我们依然可以从读写操作的维度来描述它。

对于同一台机器的两个写操作 x1 和 x2 来说：

-   如果写 x1 操作在写 x2 开始前完成，那么所有节点在最终某时间点后，都会用 x2 覆盖 x1。

对于读操作来说：

-   在数据达到最终一致性的过程中，客户端的多次观察可以看到的结果是 x1 和 x2 中的任意值；
-   在数据达到最终一致性的过程后，所有客户端都将只能观察到 x2。

我们可以看出来，“最终”是一个模糊的、不确定的概念，它是没有明确上限的，Vogels 提出这个不一致的时间窗口可能是由通信延迟、负载和复制次数造成的，但是最终所有进程的观点都一致，这个不一致的时间窗口可能是几秒也可能是几天。所以，**最终一致性是一个一致性非常低的模型**，但是它能非常高性能地实现，在一些业务量非常大，但是对一致性要求不高的场景，是非常推荐使用的

# 分布式事务与共识

## 原子提交与二阶段提交（2PC）

-   从单节点到分布式原子提交
-   两阶段提交简介

![](https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=OWM3MGJkNjM5NTk0NDYwMGI5NjdjODc5MjcxZDM1N2ZfeDM2cHZ0Y2dDODliZklpUmF4cGd3UTNNanRJeG5TV0RfVG9rZW46Ym94Y25GQmVERGJkTDlmejE5c2xMbHVrQjNnXzE2NTEyMDU3MDE6MTY1MTIwOTMwMV9WNA)

**同步阻塞问题**：二阶段提交算法在执行过程中，所有参与节点都是事务阻塞型的。也就是说，当本地资源管理器占有临界资源时，其他资源管理器如果要访问同一临界资源，会处于阻塞状态。

**协调者单点故障导致参与者长期阻塞问题**：基于 XA 的二阶段提交算法类似于集中式算法，一旦事务管理器发生故障，整个系统都处于停滞状态。尤其是在提交阶段，一旦事务管理器发生故障，资源管理器会由于等待管理器的消息，而一直锁定事务资源，导致整个系统被阻塞。

**数据不一致问题**：在提交阶段，当协调者向参与者发送 DoCommit 请求之后，如果发生了局部网络异常，或者在发送提交请求的过程中协调者发生了故障，就会导致只有一部分参与者接收到了提交请求并执行提交操作，但其他未接到提交请求的那部分参与者则无法执行事务提交。于是整个分布式系统便出现了数据不一致的问题。

**二阶段无法解决的问题**：协调者再发出DoCommit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。

-   三阶段提交
    -   超时机制
    -   准备阶段

![](https://bytedance.feishu.cn/space/api/box/stream/download/asynccode/?code=MDMzZWU2YmQ4ZTU1ZTQ3MjljMzdlODBhYjYzMGRlZGFfYU1QVTdPREx5SzB4TGQ0NmttdFRiaGJnME43U3RBYnVfVG9rZW46Ym94Y25ONTdRbkZsTEdNdm1IMzhkTnhCVHhmXzE2NTEyMDU3MDE6MTY1MTIwOTMwMV9WNA)

## 成员与协调服务

-   将工作分配给节点 Yarn
-   服务发现/成员服务 分布式远程调用框架 dubbo/thrift/grpc

# 总结

## **四种一致性**

第一，现在可以实现的一致性级别最强的是线性一致性，它是指所有进程看到的事件历史一致有序，并符合时间先后顺序, 单个进程遵守 program order，并且有 total order。

第二，是顺序一致性，它是指所有进程看到的事件历史一致有序，但不需要符合时间先后顺序, 单个进程遵守 program order，也有 total order。

第三，是因果一致性，它是指所有进程看到的因果事件历史一致有序，单个进程遵守 program order，不对没有因果关系的并发排序。

第四，是最终一致性，它是指所有进程互相看到的写无序，但最终一致。不对跨进程的消息排序

## **应用**

-   线性一致性的CAS寄存器 寄存器需要基于当前值是否等于操作给出的参数，原子地决定是否设置新值。
-   原子事务提交 数据库必须决定是否提交或终止分布式事务。
-   全序广播 消息系统必须决定传递消息的顺序。
-   锁和租约 当几个客户端争抢锁或租约时，由锁来决定哪个客户端成功获得锁。
-   成员/协调服务 给定某种故障检测器（例如超时），系统必须决定哪些节点活着，哪些节点因为会话超时需要被宣告死亡。
-   唯一性约束

## **分布式事务**

当多个事务同时尝试使用相同的键创建冲突记录时，约束必须决定哪一个被允许，哪些因为违反约束而失败。 如果你只有一个节点，或者你愿意将决策的权能分配给单个节点，所有这些事都很简单。这就是在单领导者数据库中发生的事情：所有决策权归属于领导者，这就是为什么这样的数据库能够提供线性一致的操作，唯一性约束，完全有序的复制日志，以及更多。但如果该领导者失效，或者如果网络中断导致领导者不可达，这样的系统就无法取得任何进展。应对这种情况可以有三种方法：

1.  等待领导者恢复，接受系统将在这段时间阻塞的事实。许多事务协调者选择这个选项。这种

方法并不能完全达成共识，因为它不能满足终止属性的要求：如果领导者续命失败，系统可能会永久阻塞。

1.  人工故障切换，让人类选择一个新的领导者节点，并重新配置系统使之生效，许多关系型数据库都采用这种方方式。这是一种来自“天意"的共识一一，由计算机系统之外的运维人员做出决定。故障切换的速度受到人类行动速度的限制，通常要比计算机慢（得多）。
2.  使用算法自动选择一个新的领导者。这种方法需要一种共识算法，使用成熟的算法来正确处理异常

## 建议

尽管单领导者数据库可以提供线性一致性，且无需对每个写操作都执行共识算法，但共识对于保持及变更领导权仍然是必须的。因此从某种意义上说，使用单个领导者不过是“缓兵之计”：共识仍然是需要的，只是在另一个地方，而且没那么频繁。好消息是，容错的共识算法与容错的共识系统是存在的，我们在本章中简要地讨论了它们。

像ZooKeeper这样的工具为应用提供了外包的共识、故障检测和成员服务。它们扮演了重要的角色，虽说使用不易，但总比自己去开发一个能经受第8章中所有问题考验的算法要好得多。如果你发现自己想要解决的问题可以归结为共识，并且希望它能容错，使用一个类似ZooKeeper的东西是明智之举。尽管如此，并不是所有系统都需要共识：例如，无领导者复制和多领导者复制系统通常不会使用全局的共识。这些系统中出现的冲突（参见“处理冲突"）正是不同领导者之间没有达成共识的结果，但也这并没有关系：也许我们只是需要接受没有线性一致性的事实，并学会更好地与具有分支与合并版本历史的数据打交道。

# 参考

-   [https://www.jianshu.com/p/1aa944f44b7b](https://www.jianshu.com/p/1aa944f44b7b "https://www.jianshu.com/p/1aa944f44b7b")
-   [https://time.geekbang.org/column/article/503046](https://time.geekbang.org/column/article/503046 "https://time.geekbang.org/column/article/503046")
